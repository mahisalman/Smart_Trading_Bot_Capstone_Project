import MetaTrader5 as mt5
import sqlite3
import sys
import time
from datetime import datetime

# ---------------------------
# üîê ACCOUNT CONFIGURATION
# ---------------------------
LOGIN_ID = 206426967
PASSWORD = "S@lman0193"
SERVER = "Exness-MT5Trial7"

# ---------------------------
# ‚öôÔ∏è TRADE PARAMETERS
# ---------------------------
LOT_SIZE = 0.01
TP_PIPS = [70, 100, 150, 200, 300]  # Take profits in pips (units depend on symbol pip definition)
TRADE_DEVIATION = 30
TRADE_MAGIC = 2025
DB_PATH = r"f:\cap\signals.db"
BREAKEVEN_BUFFER = 5  # pips for breakeven buffer

# ==============================
# ‚úÖ MT5 Initialization
# ==============================
def initialize_mt5():
    print("üîå Initializing MT5...")
    if not mt5.initialize():
        print(f"‚ùå MT5 init failed: {mt5.last_error()}")
        sys.exit()

    print("üîë Logging in...")
    if not mt5.login(LOGIN_ID, PASSWORD, SERVER):
        print(f"‚ùå Login failed: {mt5.last_error()}")
        mt5.shutdown()
        sys.exit()
    
    term_info = mt5.terminal_info()
    if not term_info or not term_info.trade_allowed:
        print("‚ö†Ô∏è AutoTrading is disabled or terminal info unavailable!")
        mt5.shutdown()
        sys.exit()
    
    print("‚úÖ MT5 ready.")

# ==============================
# ‚úÖ Get latest DB signal
# ==============================
def get_latest_chart_signal():
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT chart_signal FROM signal_history ORDER BY timestamp DESC LIMIT 1"
        )
        row = cursor.fetchone()
        conn.close()
        return row[0].strip().upper() if row and row[0] is not None else None
    except Exception as e:
        print(f"‚ùå DB read error: {e}")
        return None

# ==============================
# ‚úÖ Get tradeable symbol
# ==============================
def find_tradeable_gold_symbol():
    symbols = mt5.symbols_get("*XAUUSD*")
    for s in symbols or []:
        info = mt5.symbol_info(s.name)
        if info and not info.visible:
            mt5.symbol_select(s.name, True)
            info = mt5.symbol_info(s.name)  # re-fetch
        if info and info.trade_mode == mt5.SYMBOL_TRADE_MODE_FULL:
            return s.name
    print("‚ùå No tradeable XAUUSD found.")
    mt5.shutdown()
    sys.exit()

# ==============================
# ‚úÖ Helper: pip size for a symbol
# ==============================
def get_pip_value(symbol):
    info = mt5.symbol_info(symbol)
    if not info:
        raise RuntimeError("Symbol info not available for pip calculation.")
    point = info.point
    digits = info.digits
    # For FX with 4+ digits, 1 pip == point * 10 (e.g., point=0.00001 -> pip=0.0001)
    # For instruments with few digits (like XAUUSD digits often 2), treat pip == point
    if digits >= 4:
        pip = point * 10
    else:
        pip = point
    return pip, info.digits

# ==============================
# ‚úÖ Check if signal trades are active
# ==============================
def has_active_signal_trades(symbol, signal):
    """Check if there are any open or pending trades for this signal"""
    positions = mt5.positions_get(symbol=symbol) or []
    orders = mt5.orders_get(symbol=symbol) or []

    for pos in positions:
        try:
            if getattr(pos, "comment", "") == f"DB-Signal-{signal}" and getattr(pos, "magic", None) == TRADE_MAGIC:
                return True
        except Exception:
            continue

    for order in orders:
        try:
            if getattr(order, "comment", "") == f"DB-Signal-{signal}" and getattr(order, "magic", None) == TRADE_MAGIC:
                return True
        except Exception:
            continue

    return False

# ==============================
# ‚úÖ Open multiple trades per signal (only if none exist)
# ==============================
def open_multiple_trades(symbol, signal):
    tick = mt5.symbol_info_tick(symbol)
    if not tick:
        print("‚ùå Cannot fetch tick data.")
        return

    # Prevent duplicate trades for the same signal
    if has_active_signal_trades(symbol, signal):
        print(f"‚ö†Ô∏è Existing {signal} trades detected. Waiting for them to close before reopening...")
        return

    pip, digits = get_pip_value(symbol)
    direction = mt5.ORDER_TYPE_BUY if signal == "BUY" else mt5.ORDER_TYPE_SELL
    price = float(tick.ask) if signal == "BUY" else float(tick.bid)

    print(f"üöÄ Opening {len(TP_PIPS)} trades for {signal} signal at price {price} (pip={pip}, digits={digits})...")
    for i, tp_pips in enumerate(TP_PIPS):
        # Convert TP (in pips) to price offset using pip
        offset = tp_pips * pip
        tp_price = price + offset if signal == "BUY" else price - offset
        tp_price = round(tp_price, digits)

        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": LOT_SIZE,
            "type": direction,
            "price": price,
            "sl": 0.0,
            "tp": tp_price,
            "deviation": TRADE_DEVIATION,
            "magic": TRADE_MAGIC,
            "comment": f"DB-Signal-{signal}",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_IOC
        }
        result = mt5.order_send(request)
        if result is None:
            print(f"‚ùå Trade {i+1} - no response from order_send()")
            continue
        # Some brokers return structured result; print helpful info
        retcode = getattr(result, "retcode", None)
        if retcode == mt5.TRADE_RETCODE_DONE or retcode == 10009:  # 10009 sometimes used for done depending on wrapper
            print(f"‚úÖ Trade {i+1} opened | TP={tp_price} | ticket={getattr(result, 'order', 'n/a')}")
        else:
            print(f"‚ùå Trade {i+1} failed | Retcode={retcode} | Result={result}")

# ==============================
# ‚úÖ Close all opposite trades
# ==============================
def close_opposite_trades(symbol, signal):
    opposite = "SELL" if signal == "BUY" else "BUY"
    positions = mt5.positions_get(symbol=symbol) or []
    if not positions:
        return

    for pos in positions:
        try:
            if pos.comment == f"DB-Signal-{opposite}" and pos.magic == TRADE_MAGIC:
                close_type = mt5.ORDER_TYPE_SELL if pos.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
                tick = mt5.symbol_info_tick(symbol)
                if not tick:
                    print("‚ùå Cannot fetch tick to close opposite position.")
                    continue
                price = float(tick.bid) if close_type == mt5.ORDER_TYPE_SELL else float(tick.ask)
                request = {
                    "action": mt5.TRADE_ACTION_DEAL,
                    "symbol": symbol,
                    "volume": pos.volume+0.01,
                    "type": close_type,
                    "price": price,
                    "deviation": TRADE_DEVIATION,
                    "magic": TRADE_MAGIC,
                    "comment": f"Close-Opposite-{opposite}",
                    "type_time": mt5.ORDER_TIME_GTC,
                    "type_filling": mt5.ORDER_FILLING_IOC
                }
                res = mt5.order_send(request)
                print(f"‚úÖ Closed opposite {opposite} trade (ticket={pos.ticket}) | result={res}")
        except Exception as e:
            print(f"‚ö†Ô∏è Error closing opposite trade: {e}")

# ==============================
# ‚úÖ Breakeven logic (XAUUSD-optimized)
# ==============================
def get_pip_value(symbol):
    """Return pip size and digits based on symbol"""
    info = mt5.symbol_info(symbol)
    if not info:
        return 0.1, 2  # fallback for XAUUSD
    if "JPY" in symbol:
        return 0.01, info.digits
    elif "XAU" in symbol or "XAG" in symbol:
        return 0.1, info.digits
    else:
        return 0.0001, info.digits


def adjust_breakeven(symbol, signal):
    """Move SL to breakeven after 70 pips profit (for XAUUSD or similar symbols)"""
    positions = mt5.positions_get(symbol=symbol) or []
    if not positions:
        return

    pip, digits = get_pip_value(symbol)
    threshold_pips = 70  # move SL to breakeven after 70 pips profit

    for pos in positions:
        try:
            if pos.comment != f"DB-Signal-{signal}" or pos.magic != TRADE_MAGIC:
                continue

            entry_price = float(pos.price_open)
            direction = pos.type
            tick = mt5.symbol_info_tick(symbol)
            if not tick:
                continue

            current_price = float(tick.bid) if direction == mt5.ORDER_TYPE_BUY else float(tick.ask)

            # Calculate breakeven threshold and new SL
            threshold_price = entry_price + threshold_pips * pip if direction == mt5.ORDER_TYPE_BUY else entry_price - threshold_pips * pip
            new_sl = entry_price + BREAKEVEN_BUFFER * pip if direction == mt5.ORDER_TYPE_BUY else entry_price - BREAKEVEN_BUFFER * pip

            # Check if price has moved beyond threshold
            price_reached = (direction == mt5.ORDER_TYPE_BUY and current_price >= threshold_price) or \
                            (direction == mt5.ORDER_TYPE_SELL and current_price <= threshold_price)

            if price_reached:
                # Update SL only if not already moved or still below BE
                sl_current = float(pos.sl) if pos.sl else 0.0
                should_modify = False
                if sl_current == 0.0:
                    should_modify = True
                elif direction == mt5.ORDER_TYPE_BUY and sl_current < new_sl:
                    should_modify = True
                elif direction == mt5.ORDER_TYPE_SELL and sl_current > new_sl:
                    should_modify = True

                if should_modify:
                    modify_request = {
                        "action": mt5.TRADE_ACTION_SLTP,
                        "position": pos.ticket,
                        "sl": round(new_sl, digits),
                        "tp": pos.tp
                    }
                    result = mt5.order_send(modify_request)
                    if result.retcode == mt5.TRADE_RETCODE_DONE:
                        print(f"üîß SL moved to breakeven for trade {pos.ticket} | New SL={round(new_sl, digits)}")
                    else:
                        print(f"‚ö†Ô∏è SL move failed for trade {pos.ticket} | Code={result.retcode}")

        except Exception as e:
            print(f"‚ö†Ô∏è Error in breakeven logic: {e}")


# ==============================
# ‚úÖ Main Execution (example usage)
# ==============================
# if __name__ == "__main__":
#     initialize_mt5()
#     symbol = find_tradeable_gold_symbol()
#     latest_signal = get_latest_chart_signal()

#     if latest_signal:
#         print(f"üìä Latest DB Signal: {latest_signal}")
#         close_opposite_trades(symbol, latest_signal)
#         open_multiple_trades(symbol, latest_signal)

#         # Monitor for breakeven for 5 minutes (example)
#         print("‚è± Monitoring trades for breakeven (5 minutes)...")
#         start_time = time.time()
#         while time.time() - start_time < 5 * 60:
#             adjust_breakeven(symbol, latest_signal)
#             time.sleep(10)

#     mt5.shutdown()
#     print("‚úÖ Script finished.")
